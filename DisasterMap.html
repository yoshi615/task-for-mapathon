<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disaster Map</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="globe"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.152.2/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-globe@2.24.7/dist/three-globe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script>
        const canvas = document.getElementById('globe');
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 350;

        const globe = new ThreeGlobe()
            .globeImageUrl('//unpkg.com/three-globe/example/img/earth-dark.jpg')
            .bumpImageUrl('//unpkg.com/three-globe/example/img/earth-topology.png');

        scene.add(globe);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);

        // CSVデータを読み込む
        Papa.parse('added_LatLonData.csv', {
            download: true,
            header: true,
            complete: function(results) {
                const data = results.data;

                // 緯度・経度データをThreeGlobeに追加
                const pointsData = data.map(row => ({
                    lat: parseFloat(row.Latitude),
                    lng: parseFloat(row.Longitude),
                    size: 0.003, // マーカーのサイズ
                    color: 'red', // マーカーの色
                    label: `${row.Country} (${row['Disaster Type']})` // ラベル
                }));

                globe.pointsData(pointsData)
                    .pointAltitude('size') // マーカーの高さ
                    .pointColor('color'); // マーカーの色
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            globe.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Add zoom functionality with mouse scroll
        window.addEventListener('wheel', (event) => {
            const zoomSpeed = 10; // Adjust zoom speed
            camera.position.z += event.deltaY * 0.01 * zoomSpeed;
            camera.position.z = Math.max(100, Math.min(500, camera.position.z)); // Clamp zoom range
        });

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y,
                };

                globe.rotation.y += deltaMove.x * 0.005; // 横方向の回転
                globe.rotation.x += deltaMove.y * 0.005; // 縦方向の回転
                globe.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, globe.rotation.x)); // 縦回転の制限

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });
    </script>
</body>
</html>